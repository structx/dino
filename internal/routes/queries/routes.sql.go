// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: routes.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteRoute = `-- name: DeleteRoute :exec
DELETE FROM dino.routes WHERE id = $1
`

func (q *Queries) DeleteRoute(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRoute, id)
	return err
}

const insertRoute = `-- name: InsertRoute :one
INSERT INTO dino.routes ( 
    tunnel_name,
    hostname,
    destination_protocol,
    destination_ip,
    destination_port
) VALUES ( 
    $1, $2, $3, $4, $5
) RETURNING id, tunnel_name, hostname, destination_protocol, destination_ip, destination_port, is_active, created_at, updated_at
`

type InsertRouteParams struct {
	TunnelName          string
	Hostname            string
	DestinationProtocol string
	DestinationIp       string
	DestinationPort     int32
}

// InsertRoute insert new route record
func (q *Queries) InsertRoute(ctx context.Context, arg InsertRouteParams) (DinoRoute, error) {
	row := q.db.QueryRow(ctx, insertRoute,
		arg.TunnelName,
		arg.Hostname,
		arg.DestinationProtocol,
		arg.DestinationIp,
		arg.DestinationPort,
	)
	var i DinoRoute
	err := row.Scan(
		&i.ID,
		&i.TunnelName,
		&i.Hostname,
		&i.DestinationProtocol,
		&i.DestinationIp,
		&i.DestinationPort,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectActiveRoute = `-- name: SelectActiveRoute :one
SELECT
    t.id
FROM
    dino.routes as r
INNER JOIN 
    dino.tunnels as t
ON
    r.tunnel_name = t.identifier
WHERE
    hostname = $1 AND is_active = TRUE
`

// SelectActiveRoute
func (q *Queries) SelectActiveRoute(ctx context.Context, hostname string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, selectActiveRoute, hostname)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const selectManyRoutes = `-- name: SelectManyRoutes :many
SELECT
    id,
    hostname,
    is_active,
    created_at
FROM
    dino.routes
WHERE
    tunnel_name = $1
ORDER BY (id, created_at) ASC
LIMIT $2 OFFSET $3
`

type SelectManyRoutesParams struct {
	TunnelName string
	Limit      int32
	Offset     int32
}

type SelectManyRoutesRow struct {
	ID        uuid.UUID
	Hostname  string
	IsActive  bool
	CreatedAt pgtype.Timestamp
}

func (q *Queries) SelectManyRoutes(ctx context.Context, arg SelectManyRoutesParams) ([]SelectManyRoutesRow, error) {
	rows, err := q.db.Query(ctx, selectManyRoutes, arg.TunnelName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectManyRoutesRow{}
	for rows.Next() {
		var i SelectManyRoutesRow
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoute = `-- name: SelectRoute :one
SELECT
    id, tunnel_name, hostname, destination_protocol, destination_ip, destination_port, is_active, created_at, updated_at
FROM 
    dino.routes
WHERE
    id = $1
`

func (q *Queries) SelectRoute(ctx context.Context, id uuid.UUID) (DinoRoute, error) {
	row := q.db.QueryRow(ctx, selectRoute, id)
	var i DinoRoute
	err := row.Scan(
		&i.ID,
		&i.TunnelName,
		&i.Hostname,
		&i.DestinationProtocol,
		&i.DestinationIp,
		&i.DestinationPort,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectRoutesMany = `-- name: SelectRoutesMany :many
SELECT
    r.id, r.tunnel_name, r.hostname, r.destination_protocol, r.destination_ip, r.destination_port, r.is_active, r.created_at, r.updated_at,
    t.id
FROM 
    dino.routes as r
INNER JOIN
    dino.tunnels as t
ON
    r.tunnel_name = t.identitifer
WHERE
    r.tunnel_name = $1
`

type SelectRoutesManyRow struct {
	ID                  uuid.UUID
	TunnelName          string
	Hostname            string
	DestinationProtocol string
	DestinationIp       string
	DestinationPort     int32
	IsActive            bool
	CreatedAt           pgtype.Timestamp
	UpdatedAt           pgtype.Timestamp
	ID_2                uuid.UUID
}

// SelectRoutesMany
func (q *Queries) SelectRoutesMany(ctx context.Context, tunnelName string) ([]SelectRoutesManyRow, error) {
	rows, err := q.db.Query(ctx, selectRoutesMany, tunnelName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectRoutesManyRow{}
	for rows.Next() {
		var i SelectRoutesManyRow
		if err := rows.Scan(
			&i.ID,
			&i.TunnelName,
			&i.Hostname,
			&i.DestinationProtocol,
			&i.DestinationIp,
			&i.DestinationPort,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoute = `-- name: UpdateRoute :one
UPDATE dino.routes
SET
    hostname = $2,
    destination_ip = $3,
    destination_port = $4,
    destination_protocol = $5,
    is_active = $6
WHERE
    id = $1 
RETURNING id, tunnel_name, hostname, destination_protocol, destination_ip, destination_port, is_active, created_at, updated_at
`

type UpdateRouteParams struct {
	ID                  uuid.UUID
	Hostname            string
	DestinationIp       string
	DestinationPort     int32
	DestinationProtocol string
	IsActive            bool
}

func (q *Queries) UpdateRoute(ctx context.Context, arg UpdateRouteParams) (DinoRoute, error) {
	row := q.db.QueryRow(ctx, updateRoute,
		arg.ID,
		arg.Hostname,
		arg.DestinationIp,
		arg.DestinationPort,
		arg.DestinationProtocol,
		arg.IsActive,
	)
	var i DinoRoute
	err := row.Scan(
		&i.ID,
		&i.TunnelName,
		&i.Hostname,
		&i.DestinationProtocol,
		&i.DestinationIp,
		&i.DestinationPort,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
